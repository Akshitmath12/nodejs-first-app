// ********RoostGPT********
/*
Test generated by RoostGPT for test aman6March using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=39ab36566c
ROOST_METHOD_SIG_HASH=b7cd26d34e


*/

// ********RoostGPT********
import express from "express";
import mongoose from "mongoose";
import cookieParser from "cookie-parser";
import jwt from "jsonwebtoken";
import { isAuthenticated } from "../index";
import User from "../models/User";

jest.mock('jsonwebtoken');
jest.mock('../models/User');

const mockRequest = (cookies = {}) => ({
  cookies,
});

const mockResponse = () => {
  const res = {};
  res.redirect = jest.fn().mockReturnValue(res);
  return res;
};

const mockNext = jest.fn();

describe("isAuthenticated", () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });

  test("should redirect to login when no token provided", async () => {
    const req = mockRequest();
    const res = mockResponse();

    await isAuthenticated(req, res, mockNext);

    expect(res.redirect).toHaveBeenCalledWith("/login");
    expect(mockNext).not.toHaveBeenCalled();
  });

  test("should call next() when valid token provided", async () => {
    const token = "testToken";
    const userId = mongoose.Types.ObjectId();
    jwt.verify.mockReturnValueOnce({ _id: userId });
    User.findById.mockResolvedValueOnce({ _id: userId });
    const req = mockRequest({ token });
    const res = mockResponse();

    await isAuthenticated(req, res, mockNext);

    expect(jwt.verify).toHaveBeenCalledWith(token, "sdjasdbajsdbjasd");
    expect(User.findById).toHaveBeenCalledWith(userId);
    expect(req.user).toEqual({ _id: userId });
    expect(mockNext).toHaveBeenCalled();
    expect(res.redirect).not.toHaveBeenCalled();
  });
});
