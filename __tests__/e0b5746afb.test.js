// ********RoostGPT********
/*
Test generated by RoostGPT for test aman6March using AI Type Open AI and AI Model gpt-4

ROOST_METHOD_HASH=e40d9c5245
ROOST_METHOD_SIG_HASH=e0b5746afb


*/

// ********RoostGPT********
// Import necessary modules
import request from 'supertest';
import express from 'express';
import mongoose from 'mongoose';
import bcrypt from 'bcrypt';
import jwt from 'jsonwebtoken';
import cookieParser from 'cookie-parser';

// Mock User model
const User = {
  findOne: jest.fn(),
  create: jest.fn()
};

// Mock bcrypt
jest.mock('bcrypt', () => ({
  hash: jest.fn(() => 'hashedPassword')
}));

// Mock jwt
jest.mock('jsonwebtoken', () => ({
  sign: jest.fn(() => 'token')
}));

// Mock express app and route handler
const app = express();
app.use(express.json());
app.use(cookieParser());
app.post("/register", async (req, res) => {
  const {
    name,
    email,
    password
  } = req.body;
  let user = await User.findOne({
    email
  });
  if (user) {
    return res.redirect("/login");
  }
  const hashedPassword = await bcrypt.hash(password, 10);
  user = await User.create({
    name,
    email,
    password: hashedPassword
  });
  const token = jwt.sign({
    _id: user._id
  }, "sdjasdbajsdbjasd");
  res.cookie("token", token, {
    httpOnly: true,
    expires: new Date(Date.now() + 60 * 1000)
  });
  res.redirect("/");
});

describe('POST /register', () => {
  beforeEach(() => {
    User.findOne.mockClear();
    User.create.mockClear();
    bcrypt.hash.mockClear();
    jwt.sign.mockClear();
  });

  it('should redirect to /login if user already exists', async () => {
    User.findOne.mockResolvedValueOnce({ _id: 'existingUserId' });

    const response = await request(app)
      .post('/register')
      .send({
        name: 'Test User',
        email: 'test@example.com',
        password: 'password'
      });

    expect(User.findOne).toHaveBeenCalledWith({ email: 'test@example.com' });
    expect(response.headers.location).toBe('/login');
  });

  it('should create a new user and set a cookie if user does not exist', async () => {
    User.findOne.mockResolvedValueOnce(null);
    User.create.mockResolvedValueOnce({ _id: 'newUserId' });

    const response = await request(app)
      .post('/register')
      .send({
        name: 'Test User',
        email: 'test@example.com',
        password: 'password'
      });

    expect(User.findOne).toHaveBeenCalledWith({ email: 'test@example.com' });
    expect(bcrypt.hash).toHaveBeenCalledWith('password', 10);
    expect(User.create).toHaveBeenCalledWith({
      name: 'Test User',
      email: 'test@example.com',
      password: 'hashedPassword'
    });
    expect(jwt.sign).toHaveBeenCalledWith({ _id: 'newUserId' }, 'sdjasdbajsdbjasd');
    expect(response.headers['set-cookie']).toEqual(expect.arrayContaining(['token=token; Path=/; HttpOnly; Expires=']));
    expect(response.headers.location).toBe('/');
  });
});
